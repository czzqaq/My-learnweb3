# 目录

## 基础概念

### 去中心化

交易记录在 Block 上，若干个交易记录填满一个 block 后，block 被加入到区块链上，这叫做入链。web3 网络上的每一个节点，都会保存完整的区块链数据，上面有交易记录。通过验证交易记录，就可以保证交易的真实性。合约的字节码也保存在区块链。对于什么是区块，见：[区块](./区块.md)

此外，合约的Storage、以及日志，也是去中心化的，但是它们不在区块上，而是存储在区块链节点的数据库中。日志是写，读，而不修改的，所以保存起来更简单，而合约的状态则以 Merkle Patricia Trie 的形式保存。

还有Oracle、IPFS等，虽然不在链上，和外部打交道，但是也是去中心化的。


#### 这不是很费资源吗

是的，非常费资源。但是，也没有那么离谱。

首先，合约不是部署在区块上。合约的状态是以trie 储存的，每次写也不是修改全部的数据，而是只修改部分节点。

其次，不是所有节点都会保存数据，存在几种节点：全节点、轻节点。全节点保存所有数据，而轻节点只存储区块头信息，用来查询全解点的信息，做验证。还有归档节点，保存历史状态和区块数据，但不做验证。


#### 共识算法

共识是指多个借点或者代理在区块链上达成一致的能力，保证区块链不会分叉。共识算法有POW, POS等。比如常说的比特币，就是指节点发现了一个或多个哈希的原始字符串，从而证明了自己有算出难题的能力，即POW。而POS 是说，你进行抵押，如果干活出错了，会被惩罚。POA 是简简单单的授权，比较适合简单的、私人的网络。

经常听说的矿工，就是通过了POW 共识算法的节点，它们是全节点（不过不是所有的全节点都是矿工）。

> This is a good point at which to mention that neither proof of work nor proof of stake is
>  a consensus protocol in itself. They are often (lazily) referred to as consensus protocols, 
> but each is merely an enabler for consensus protocols.

具体的共识内容，见：[共识](./共识.md)

### 安全性

#### data availablity

data availablity 是重要的保证安全性的手段。因为所有人都可以从任意一个节点获取数据，所以，如果有人恶意篡改数据，那么其他人就可以通过比对数据，发现问题。

或者说，区块链的去中心化本来就是其安全性的保证。


#### 签名方式

签名使用ECDSA 算法。被签名的是交易的 hash ，因为交易太长，而且要验证整个交易的完整性，所以比如只拿交易的前256字节做签名的办法绝对不行。

先说椭圆曲线。签名要满足，已知无数多次的签名S，也极其难推断出来私钥d，关于这一点，非对称签名用的都是类似于离散模域对数难以求的问题，因为指数要绕好几个圈，所以算指数容易，而对数的单调性已经被破坏了，不能用逼近的方法求根。函数本身是非线性的，所以也不可能相加减找一个 d 的明确的方程出来。椭圆曲线系的非对称加密，是用椭圆曲线上的加法定义，以及加很多次最终肯定会绕回去，得到了一个指数计算的同构。指数能绕一圈是因为费马小定理，椭圆曲线上的就很显然：首先域的大小有限，也就是你一个数自己不停的加，总会回到之前的结果。现在的问题是，为什么加法总是会绕一个恰到好处的环，回到O，而不是先走一段距离，变成一个混循环小数的感觉呢？因为加法满足结合律和交换律（这个好证），所以出现在任何地方的加法都是地位等同的。这当然是非常不严谨的数学证明，不过我就这样理解了。于是，我们定义 Q = dG，其中Q是公钥，G是基点，d是私钥。已知私钥求公钥很好求，而已知公钥求私钥非常困难。


签名的过程是fiat-shamir 变换。它的背景是交互式验证，然后改为非交互式。显然，签名的过程需要不可重复，也就是攻击者重放签名的报文没意义，于是，肯定要引入一个随机数 r，作为题目，每次验证都是新的。另外，当然还有 EOA 账户的私钥 d。可以预见的，签名起码是 r 和 d 的函数。实际的签名总是还有一个未知数k，它是生成的临时私钥。这个k 是为什么呢？chatgpt 的理解是，因为r 是公开的，所以如果同样的r 题目，就可以用重放攻击了，所以引入一个k 以后，无论如何攻击者都不知道这个隐藏的随机数是多少，题目都看不全（当然随机一个r肯定题目的数量很多，但题目终究还是公开的）。

以上是交互式验证的过程。对于非交互式验证，区别在于 r 也由被验证者生成。这样，当然没有办法防止重放攻击了。单一的fiet shamir 变换并不能防止重放攻击，往往需要结合时间戳、nonce 等。而web3 签名验证确实有nonce，重放之后用的还是之前的nonce，所以这样的重放是无效的。

一些细节：

- 在web3 验证中，r = cordx（kG）mod n。s = k^-1（hash(e) + dr）mod n。验签时要有：g = hash(e)/s G + r/s Q, cordx（g）= r。 

- 在 EIP-155 之后，block.number >= FORK_BLKNUM。一个交易中有：v,r,s 三个和签名有关的字段。r 和 s 的含义见前文。此外，v 用来区别不同链，以及用来指明 r 的y 坐标点的正负（提供了x，可以通过曲线方程得到一对对称的y）。v=CHAIN_ID * 2+35+{0,1}，v 是奇数，则y 是正的，v 是偶数，则y 是负的。

- 在 EIP-155 之后，block.number >= FORK_BLKNUM。交易的哈希值是通过 (nonce, gasprice, startgas, to, value, data, chainid, 0, 0) 计算得来的，把chainid 纳入其中，杜绝了跨链重放攻击。哈希函数是keccak256。